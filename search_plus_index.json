{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《计算机程序的构造与解释》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-10-21 18:37:55 "},"第1章-构造过程抽象.html":{"url":"第1章-构造过程抽象.html","title":"第1章-构造过程抽象","keywords":"","body":"1. 程序设计的基本元素1.1. 表达式1.2. 命名和环境1.3. 组合式的求值1.4. 复合过程1.5. 过程应用的代换模型1.6. 条件表达式和谓词1.7. 实例：采用牛顿求平方根1.8. 过程作为黑箱抽象1.8.1. 局部名1.8.2. 内部定义和块结构2. 过程及其产生的计算2.1. 线性的迭代和递归2.2. 树形递归3. 用高阶函数做抽象3.1. 过程作为参数3.2. 用lambda构造过程3.2.1. 用let创建局部变量3.3. 过程作为一般性的方法3.4. 过程作为返回值 计算过程是存在于计算机里的一类抽象事物，在其演化进程中，这些过程会去操作一些被称为数据的抽象事物。 我们用于指挥这种过程的程序就像巫师的咒语，它们是用一些诡秘而深奥的程序设计语言，通过符号表达式的形式精心编排而成。 现存的许多威力强大的程序设计技术，都依赖于填平在“被动的”数据和“主动的”过程之间的传统划分。 1. 程序设计的基本元素 一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。 每一种强有力的语言都提供了三种机制“ 基本表达形式：用于表示语言所关心的最简单的个体。 组合的方法：通过它们可以从较简单的东西出发构造出复合的元素。 抽象的方法：通过它们可以为复合对象命名，并将它们当作单元去操作。 1.1. 表达式 表达式：数就是一种基本表达式，与此同时可以用基本过程的表达形式（例如运算符），将各表达式组合起来形成复合表达式。 组合式：用一对括号括起一些表达式，形成一个表，用于表示一个过程应用。 表中最左元素是运算符，代表解释器内嵌的一个过程。 其他元素是运算对象。 1.2. 命名和环境 程序设计语言中一个必不可少的方面，就是提供一种通过名字去使用计算对象的方式，我们将名字标识符称为变量，它的值也就是它所对应的那个变量。 我们如果想要将值与符号相关联，就意味着解释器必须维护某种存储能力，以便保持有关的name-value对偶的轨迹。这种存储被称为 环境 。 1.3. 组合式的求值 求值一个组合式的步骤： 求值该组合式的各个子表达式。 将作为最左子表达式（运算符）的值所对应的那个过程应用于相应的实际参数，即其它子表达式（运算对象）的值。 上面的递归步骤会触及如下的base-case： 数的值就是它们所表示的数值。 内部运算符的值就是解释器中内嵌的机器指令序列。 其他名字的值就是在环境中关联于此名字的那个对象。 对于初学者，应该指出的关键一点是：环境所扮演的角色就是用于确定表达式中各个符号的意义。 请注意，上述规则并没有处理define，(define x 3)的求值并非将define应用于后面的两个实参，而是在环境中为x关联一个值。因此(define x 3)并非一个组合式。 这种一般性求值的例外情况被称为 特殊形式 ，这种特殊语法形式通常被称为 语法的糖衣 。虽然语法糖短视地看带来了“方便”，但语法糖过多的程序设计语言缺少统一性，当程序更大更复杂时会带来麻烦。 1.4. 复合过程 过程定义：这是一种为例更加强大的抽象技术，通过它可以为复合操作提供名字，而后可以将此操作作为一个单元使用。lisp的过程定义格式： (define ( ) ) 1.5. 过程应用的代换模型 对于复合过程，过程应用的计算过程是：将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。这种计算过程被称为过程应用的代换模型。 代换模型的求值方式一般有应用序和正则序两种。 应用序：先求值参数而后应用，它可以避免重复计算。 正则序：完全展开而后规约。 1.6. 条件表达式和谓词 Lisp的条件表达式如下： (cond ( ) ( ) ... ( )) 条件表达式的求值方式如下：依次求值谓词\\，直至某个谓词为true，就将子句中对应的序列表达式\\的值作为整个条件表达式的值。如果全为false，cond的值就没有定义。 Lisp的if，它是条件表达式的一种受限形式： (if ) 1.7. 实例：采用牛顿求平方根 具体例子不写了，讲一下这节中提到的一个思想。 函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异之间的具体反应。 换一种说法，这是说明性的知识（What to do）与行动性的知识（How to do）之间的差异。 在数学中，人们通常关心说明性的描述；在计算机科学中，人们通常关心行动性的描述。 1.8. 过程作为黑箱抽象 对于平方根的计算问题可以自然地分解为若干子问题，而这种从原问题到子问题的问题分解也对应了代码中的过程分解： 虽然说我们总可以拿来一个大程序，然后进行“粗暴的分解”——前10行是一部分，后10行是另一部分……但显然上面的过程分解有如下的特点： 分解的每个过程完成了一件可以清楚标明的工作，这使得它们成为可以被用作它用的“模块”。 而且这种“黑箱”的抽象方式实现了外部接口使用与内部具体实现之间的分离，其内部的计算细节被隐去了，从而可以推迟到以后再考虑。 一个过程定义应该可以隐藏起一些细节，这使得过程的使用者可以不必自己去实现细节，而是从其它程序员那里作为一个黑箱接受它。 1.8.1. 局部名 在过程体中，过程的形式参数的具体名字是什么完全没有关系，如果将某个形参统一换名，其意义将没有任何改变。 这样的名字称为 约束变量 ，因此一个过程的定义约束了它的所有形式参数。 如果一个变量不是被约束的，那么它就是 自由变量 。 一个名字的定义被约束于的那一块表达式被称为该名字的作用域。 1.8.2. 内部定义和块结构 对于大型系统，程序员一般会有如下的“问题”： 对于一个暴露给外部的“功能过程”，通常我们需要若干仅供此“功能过程”使用的“辅助过程”，而这些“辅助过程”并不需要暴露给外部。 虽然外部可以主动不去调用“辅助过程”，但是这些庞杂的“辅助过程”会产生一个副作用——挤占外部环境的命名空间。例如我们会为许多“功能过程”的数量巨大“辅助过程”的取名而抓耳挠腮。 于是一个需求诞生了：我们希望将这些“辅助过程”局部化，将它们隐藏到对于的“功能过程”中，既保证了安全，也腾出了命名空间。 我们可以像下面的代码一样实现局部于过程的内部定义： (define (sqrt x) (define (good-enough? guess) ( 这种嵌套的定义称为块结构，它是最简单的名字包装问题的一种正确解决方式。 块结构不仅实现了将辅助过程放到内部，还让x成为内部定义中的自由变量。 块结构带来的副作用（挺好的副作用）：细化了作用域粒度，这种方式称为 词法作用域 。 块结构的思想来自程序设计语言Algol 60，这种结构出现在各种最新的程序设计语言里，是帮助我们组织大程序的结构的一种重要弓箭。 2. 过程及其产生的计算 能够看清所考虑的动作的后果的能力，对于成为程序设计专家是至关重要的。我们只有学会去看清各种不同种类的过程会产生什么样的计算过程，才能学会如何去构造可靠的程序，使之能够表现出所需要的行为。 一个过程也就是一种模式，它描述了一个计算过程的局部演化方式，描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。 2.1. 线性的迭代和递归 对于阶乘函数，我们有递归和迭代两种实现： 递归版本： (define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) 迭代版本： (define (factorial n) (fact-iter 1 1 n)) (define (fact-iter product counter max-count) (if (> counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) 对于递归过程，代换模型揭示出一种先逐步展开而后收缩的形状。 在展开阶段，这一计算过程构造起一个推迟进行的操作所形成的链条。 在收缩阶段，则是这些运算的实际执行。 这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个递归计算过程。 对于迭代过程，他并没有任何增长或收缩。 迭代计算过程是状态可以用固定数目的状态变量描述的计算过程； 与此同时也存在一套固定的规则，描述了计算过程在从一个状态到下一个状态转换时，这些状态变量的更新方式； 最后还有一个结束检测，用以描述计算过程的终止条件。 关于 递归计算过程 和 递归过程 的概念辨析： 递归过程：这是一个语法形式上的事实，说明这个过程的定义中（直接或间接地）引用了该过程本身。 递归计算过程：这是一个计算过程的进展方式，表示其拥有先逐步展开而后收缩计算的模型。 基于上述概念，我们需要提醒一下： 对于上面的fact-iter，它是一个递归过程（因为它直接引用了自己），但这个递归过程产生出一个迭代计算过程。（好吧，这样说确实有些奇怪，但事实就是如此。） 之所以当我们区分 形式上写出来的过程 和 实际上的计算过程 时会令人困惑，是因为大部分常见语言在设计时会使用特殊的“循环结构”来描述迭代计算过程，而将所有 形式上的递归过程 全部翻译成 实际上的递归计算过程 ，即使形式上的递归过程描述的其实是迭代计算过程（例如fact-iter）。 总而言之，从实现细节来看，需要提醒一点：Scheme只有通过尾递归才能表述循环，不存在特殊的循环或迭代结构。也就是说，Scheme总能在常量空间中执行迭代型计算过程，即使这一计算过程是用一个递归过程描述的。从这个角度来看，其他语言的各种复杂的专用迭代结构不过是一些语法糖衣罢了。 2.2. 树形递归 (define (fib n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fib (- n 1)) (fib (- n 2)))))) 树形递归计算模型里所需的步骤数正比于树中节点数，空间需求正比于树的最大深度。 虽然改写为迭代计算过程可以显著降低时间/空间复杂度，但也不能说树形递归计算过程毫无用处。 树形递归计算过程是一种自然而威力强大的工具，可以帮助我们理解和设计程序。 3. 用高阶函数做抽象 在作用上，过程也是一类抽象，它们描述了一些对于数的符合操作，但又不依赖于特定的数。 加入我们强迫自己不使用过程这一工具，我们是可以完成任意复杂的任务的。但是这会迫使我们永远在语言提供了的特定基本操作的层面上工作，而不能跳到更高级的抽象层面上去。 这使得人们对功能强大的程序设计语言有一个必然要求：就是能为公共的模式建立抽象，然后直接在抽象的层次上工作。这也是为什么几乎所有的程序设计语言都包含过程机制的原因。 但是，如果将过程限制为只能以数作为参数，也会严重限制建立抽象的能力。因为经常有一些同样的程序设计模式能用于若干不同过程，因此我们引入了高阶过程：能操作过程的过程。 3.1. 过程作为参数 考虑如下所谓的“求和模板”： $$ \\sum_{n=a}^{b}f(n)=f(a)+f(a+1)+...f(b) $$ “求和模板”的威力在于它使数学家能去处理求和的概念本身，而不只是某个特定的求和。 与之类似的，我们也自然地希望所用的语言足够强大，能够支持我们写出一个过程，去表达求和的概念而非特定的求和。例如： (define (sum term a next b) (if (> a b) 0 (+ (term a) (sum term (next a) next b)))) ; 立方和 (define (inc n) (+ n 1)) (define (cube n) (* n n n)) (define (sum-cubes a b) (sum cube a inc b)) 一旦有了sum，我们就就能用它作为基本构件，去形式化其他概念。 3.2. 用lambda构造过程 在上一节中，我们需要显式地定义出一系列简单函数，用来作为高阶函数的参数。这显然并不方便，于是我们引入一种lambda特殊形式完成所谓的“匿名过程”。这种过程没有与环境中任何名字相关联。 (lambda () ) 3.2.1. 用let创建局部变量 假如我们想要使用局部变量来如下优化函数： $$ f(x,y)=x(1+xy)^2+y(1-y)+(1+xy)(1-y)\\ a=1+xy\\ b=1-y\\ f(x,y)=xa^2+yb+ab $$ 一种方式是使用辅助过程去约束局部变量： (define (f x y) (define (f-helper a b) (+ (* x (square a)) (* y b) (* a b))) (f-helper (+ 1 (* x y)) (- 1 y))) 另一种方法就是使用一个lambda表达式，用以描述约束局部变量的匿名过程： (define (f x y) ((lambda (a b) (+ (* x (square a)) (* y b) (* a b))) (+ 1 (* x y)) (- 1 y))) 我们还可以使用一种专门的特殊形式称为let，使这种编程方式更为方便： (define (f x y) (let ((a (+ 1 (* x y))) (b (- 1 y))) (+ (* x (square a)) (* y b) (* a b)))) let表达式的一般形式是： (let (( ) ( ) ... ( )) ) #| 读作： 令 具有值 而且 具有值 而且 ... 具有值 在 中 |# 需要提的一点是：let表达式只是作为其基础的lambda表达式的语法外衣罢了。 let表达式描述的变量的作用域就是该let的体。 let使人能在尽可能接近其使用的地方建立局部变量约束。 变量的值是在let之外计算的。在为局部变量提供值的表达式依赖于某些与局部变量同名的变量时，这一规定就起作用了。例如，假设外部x的值是2，表达式： (let ((x 3); 局部变量x=2 (y (+ x 2))); 外部变量x=3 (* x y)); =12 3.3. 过程作为一般性的方法 3.4. 过程作为返回值 By YangXin Xu            updated 2023-10-22 11:28:51 "},"第2章-构造数据抽象.html":{"url":"第2章-构造数据抽象.html","title":"第2章-构造数据抽象","keywords":"","body":"1.1. 抽象数据导引1.2. 实例：有理数的算术运算1.2.1. 序对1.2.2. 有理数的表示1.3. 抽象屏障1.4. 数据意味着什么1.5. 层次性数据和闭包性质1.6. 序列的表示1.6.1. 表操作1.6.2. 对表的映射1.7. 层次性结构1.8. 序列作为一种约定的界面1.8.1. 序列操作1.9. 实例：一个图形语言2. 符号数据2.1. 引号2.2. 实例：符号求导2.3. 实例：集合的表示2.4. 实例：Huffman编码树3. 抽象数据的多重表示3.1. 复数的表示 为什么在程序设计语言里需要复合数据呢？与我们需要符合过程的原因一样：同样是为了提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样，能够构造复合数据的能力，也将使我们得以在比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。 数据抽象技术：将程序中处理数据对象的表示的部分，和处理数据对象的使用的部分相互隔离的技术。 形成复合数据的关键在于，程序设计语言里应该提供了某种“黏合剂”，可以用于把一些数据对象组合起来，形成更复杂的数据对象。 闭包：用于组合数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象。 符号表达式：它的基本部分可以是任意的符号而不一定是数。 通用型操作：这种操作必须能处理许多不同的数据类型，为了维持模块性，通用型操作的出现将要求比只有简单数据抽象更强大的抽象屏障。 数据导向的程序设计：它允许我们孤立地设计每种数据表示，而后用添加的方式将它们组合进去。 1.1. 抽象数据导引 数据抽象是一种方法学，它使我们能将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。 数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样；与此同时，一种“具体数据”表示的定义，也应该与程序中使用数据的方式无关。 “抽象数据”的使用与“具体数据”的定义之间的界面是一组过程，称为选择函数和构造函数，它们在具体表示之上实现抽象的数据。 1.2. 实例：有理数的算术运算 我们首先预定义有理数的相关接口（目前尚未实现）： (make-rat );返回一个有理数，其分子是整数，分母是整数 (number );返回有理数的分子 (denom );返回有理数的分母 现在我们使用一种 按愿望思维 的综合策略，即假设我们已经实现了上述“抽象数据”的具体定义，从而进一步去实现有理数的相关运算过程： (define (add-rat x y) (make-rat (+ (* (number x) (denom y)) (* (number y) (denom x))) (* (denom x) (denom y)))) (define (sub-rat x y) (make-rat (- (* (number x) (denom y)) (* (number y) (denom x))) (* (denom x) (denom y)))) (define (mul-rat x y) (make-rat (* (number x) (number y)) (* (denom x) (denom y)))) (define (div-rat x y) (make-rat (* (number x) (denom y)) (* (denom x) (number y)))) (define (equal-rat? x y) (= (* (number x) (denom y)) (* (number y) (denom x)))) 而目前我们需要有某种方式，将一个分子和一个分母黏合起来，构成一个有理数。 1.2.1. 序对 lisp提供一种称为序对的复合结构，这种结构可以通过基本过程cons构造出来，也可以通过基本过程car和cdr提取。 (define x (cons 1 2)) (define x (cons 3 4)) (define z (cons x y)) (car (car z)) 1 (car (cdr z)) 3 从序对构造起来的数据对象称为表结构数据。 1.2.2. 有理数的表示 利用上一小节介绍的序对，我们可以轻松地实现有理数的预定义接口： (define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) (define (number x) (car x)) (define (denom x) (cdr x)) (define (print-rat x) (newline) (display (number x)) (display \"/\") (display (denom x))) 1.3. 抽象屏障 一般而言，数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得这类数据对象的所有操作都可以基于它们表述，同时在操作这些数据对象时也只能使用它们。 我们可以利用下图形象化地展示有理数系统的结构： 这种方法是程序很容易维护和修改。 当然表示方式的选择会对操作它的程序产生影响，如果后来表示方式改变了，所有相关程序都要随之改变。 1.4. 数据意味着什么 一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及为使这些过程成为一套合法表示，它们所必须满足的一组特定条件。 这里我们需要提出一种初听会令人吃惊的观点：我们可以完全不适用任何数据结构，只使用过程就可以定义数据。人们也称其为数据的过程性表示。 数据的过程性表示将在我们的程序设计宝库里扮演一种核心角色。有关的程序设计风格称为消息传递。 1.5. 层次性数据和闭包性质 首先来看一些复合序对的盒子和指针表示： 一般说某种组合数据对象的操作满足闭包性质，就是说通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。 属于“闭包”来自抽象代数。在抽象代数中，一个集合在某个运算之下封闭，如果该运算应用于这一集合中的元素，得到的结构仍是该集合中的元素。 然而Lisp社团很不幸用此术语来描述了另一个毫不相干的概念。这个概念更类似于自举。 1.6. 序列的表示 利用序对可以构造出序列——一批数据对象的有序汇集。一种实现方法就是使用嵌套的cons： 通过嵌套的cons形成的序列称为一个表，Scheme为方便表的构造，提供了一个基本操作list： (list ... ) ;等价于 (cons (cons (cons ... (cons nil) ... ))) 1.6.1. 表操作 ;list-ref表示取出表items中的第n个元素 (define (list-ref items n) (if (= n 0) (car items) (list-ref (cdr items) (- n 1)))) Scheme包含一个基本操作null?，用于检查参数是否是空表，因此计算表长的过程可实现如下： (define (length items) (if (null? items) 0 (+ 1 (length (cdr items))))) 1.6.2. 对表的映射 一个特别有用的操作是将某种变换应用于一个表中所有元素，得到所有结果构成的表，就像下面这个过程一样： (define (scale-list items factor) (if (null? items) nil (cons (* (car items) factor) (scale-list (cdr items) factor)))) 我们可以将上述例子进行抽象，将其中的公共模式表述为一个高阶过程map，它有一个过程参数proc和一个表参数items，返回结果表： (define (map proc items) (if (null? items) nil (cons (proc (car items)) (map proc (cdr items))))) ; 给出上面例子的新定义 (define (scale-list items factor) (map (lambda (x) (* x factor)) items)) map帮我们建立起一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开来。 这种抽象也因此提供了新的灵活性，使我们可以在保持从序列到序列的变换操作框架的同时，改变序列实现的底层细节。 1.7. 层次性结构 进一步推广，我们可以构造出元素是序列的序列。 同样的，我们可以用上面的map来对具体的树映射操作进行定义： (define (scale-tree tree factor) (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor))) tree)) 1.8. 序列作为一种约定的界面 我们引入两个问题：奇数叶子平方求和问题 和 斐波那契偶数求和问题，它们有如下的过程实现： (define (sum-odd-squares tree) (cond ((null? tree) 0) ((not (pair? tree)) (if (odd? tree) (square tree) 0)) (else (+ (sum-odd-squares (car tree)) (sum-odd-squares (cdr tree)))))) (define (even-fibs n) (define (next k) (if (> k n) nil (let ((f (fib k))) (if (even? f) (cons f (next (+ k 1))) (next (+ k 1)))))) (next 0)) 我们可以去寻找两者的共性，并绘制出如下的信号流图来揭示这一点： 显然上面的过程定义并没展现出这种信号流结构。 上面两个过程采用了不同的方式分解了计算，将枚举工作散布在程序中，并和映射、过滤器、累计器相混合，降低了代码的清晰度。 1.8.1. 序列操作 显然有了之前的种种铺垫，最直接的想法就是使用一些表来表示这些信号，从而利用表操作实现每一步骤的处理。 枚举：这一操作是与具体问题耦合的。 (define (enumerate-interval low high) (if (> low high) nil (cons low (enumerate-interval (+ low 1) hight)))) (define (enumerate-tree tree) (cond ((null? tree) nil) ((not (pair? tree)) (list tree)) (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree)))))) 映射：使用已经实现的map操作 (define (map proc items) (if (null? items) nil (cons (proc (car items)) (map proc (cdr items))))) 过滤： (define (filter predicate sequence) (cond ((null? sequence) nil) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence))))) 累积： (define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence))))) 管道式连接：按照信号流图进行连接。 (define (sum-odd-squares tree) (accumulate + 0 (map square (filter odd? (enumerate-tree tree))))) (define (even-fibs n) (accumulate cons nil (filter even? (map fib (enumerate-interval 0 n))))) 在工程设计中，模块化是控制复杂性的一种威力强大的策略。而上述的序列操作也形成了一个可以混合和匹配使用的标准程序元素库。 用表实现的序列可被作为一种方便的界面，我们可以利用这个界面去组合起各种处理模块。 如果以序列作为所用的统一表示结构，我们就能将程序对于数据结构的依赖性局限到为数不多的解序列操作上。 打个比方： 程序 $\\Longleftrightarrow$ 电网，数据结构 $\\Longleftrightarrow$ 用电器。 本节的最初实现就是：将用电网的电线和用电器的电线通过复杂的方式耦合连接，两者之间有许多不同的连接点。 用序列实现的界面 $\\Longleftrightarrow$ 模块化的插头、插座。将电网对各种用电器的依赖性局限到为数不多的接触点上。 1.9. 实例：一个图形语言 （略） 2. 符号数据 目前为止所有的复合数据都是从数值出发构造起来的，我们可以进一步扩充语言表述能力，引进将任意符号作为数据的能力。 2.1. 引号 我们可以将表和符号标记为“作为数据对象看待”，而非作为求值的表达式。 在Scheme中，我们只需在被引对象前面放一个单引号（可以不写结束引号），就可以表达上述含义。 (define a 1) (define b 2) (list a b) (1 2) (list 'a 'b) (a b) (list 'a b) (a 2) (car '(a b c)) a (cdr '(a b c)) (b c) 严格地说，引号的这种使用方式违背了我们语言中“所有复合表达式都应该由括号限定，都具有表形式的普遍性原则。 可以通过引入特殊形式 quote 来恢复一致性：’a $\\Leftrightarrow$ (quote a)。实际上也是解释器的工作方式，引号只是(quote \\)的缩写形式。 eq?：一个基本过程，用以判断两个符号是否相同。 2.2. 实例：符号求导 （略） 2.3. 实例：集合的表示 （略） 2.4. 实例：Huffman编码树 （略） 3. 抽象数据的多重表示 一个数据对象可能存在多种有用的表示方式，而且我们也可能希望所设计的系统能处理多种表示形式。例如复数有 直角坐标形式 和 极坐标形式 ，这两种形式在不同的情况下都有其方便之处。 除此以外，一个系统的程序设计常常是多人长时间合作完成的，并且系统需求也在随时间而不断变化。在这种环境中，要求每个人都在数据表示的选择上达成一致是不可能的。 因此，我们不仅需要隔离数据的表示与使用，还需要隔离互不相同的数据表示。 3.1. 复数的表示 By YangXin Xu            updated 2023-10-22 16:29:55 "}}